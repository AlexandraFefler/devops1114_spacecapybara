name: CI/CD pipeline

on:
  push:
    branches:
      - main

jobs:

  DEBUGGG-gcp:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Authenticate with GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Install gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: automated-lodge-449109-b9

      - name: Verify Authentication
        run: |
          gcloud auth list
          echo "-------ended the gcp auth debug thing--------"

  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Create .env file
        run: echo "${{ secrets.ENV_FILE }}" > .env

      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_HUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin

      - name: Build Docker image
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          docker build -t $DOCKERHUB_USER/spacecapybara_app:${VERSION} .

      - name: Push Docker image to Docker Hub (only with ver)
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          docker push $DOCKERHUB_USER/spacecapybara_app:${VERSION}
          
      - name: Push Docker image to Docker Hub (as latest stable)
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          docker tag $DOCKERHUB_USER/spacecapybara_app:${VERSION} $DOCKERHUB_USER/spacecapybara_app:latest
          docker push $DOCKERHUB_USER/spacecapybara_app:latest

  test-container:
      runs-on: ubuntu-latest
      needs: build-and-push

      steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Create required files
        run: |
          echo "${{ secrets.ENV_FILE }}" > .env
          echo "${{ secrets.INIT_SQL }}" > init.sql

      - name: Run Docker Compose
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          run: |
          echo "DOCKERHUB_USER=${DOCKERHUB_USER}" >> .env  # Inject variables into .env
          echo "VERSION=${VERSION}" >> .env  # Inject variables into .env
          cat .env  # Debugging step to verify environment variables
          docker compose up -d --force-recreate
        # run: |
        #   DOCKERHUB_USER=$DOCKERHUB_USER VERSION=$VERSION docker compose up -d --force-recreate
      
      - name: Test Application with Curl
        run: |
          sleep 30  # Wait for the container to start
          docker compose logs
          if curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:5002 | grep -q "^200$"; then
              echo "Test passed: App is responding with HTTP 200."
          else
              echo "Test failed: App is not responding with HTTP 200."
              exit 1
          fi

      - name: Stop and Clean Up Containers
        run: docker compose down

  # infrastructure-provisioning:
  #   runs-on: ubuntu-latest
  #   needs: [build-and-push, test-container]

  #   outputs:
  #     EC2_PUBLIC_IP: ${{ steps.get-ec2-ip.outputs.EC2_PUBLIC_IP }}

  #   steps:
  #     - name: Check out repository
  #       uses: actions/checkout@v4

  #     - name: Move to Terraform directory
  #       run: cd ec2_provision

  #     - name: Setup Terraform
  #       uses: hashicorp/setup-terraform@v2
  #       with:
  #         terraform_version: 1.10.4

  #     - name: Configure AWS credentials
  #       uses: aws-actions/configure-aws-credentials@v2
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         aws-region: us-east-1 

  #     - name: Initialize Terraform
  #       run: |
  #         cd ec2_provision
  #         terraform init

  #     - name: Apply Terraform Configuration
  #       run: |
  #         cd ec2_provision
  #         terraform apply --auto-approve

  #     - name: Get EC2 Public IP
  #       id: get-ec2-ip
  #       run: |
  #         cd ec2_provision
  #         TERRAFORM_IP=$(terraform output -raw public_ip | awk 'match($0, /([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/) {print substr($0, RSTART, RLENGTH); exit}')
  #         echo "Extracted EC2_PUBLIC_IP: '$TERRAFORM_IP'"
  #         echo "EC2_PUBLIC_IP=$TERRAFORM_IP" >> $GITHUB_ENV
  #         echo "::set-output name=EC2_PUBLIC_IP::$TERRAFORM_IP"


  #     # - name: Store EC2 Public IP as GitHub Actions Environment Variable
  #     #   run: echo "EC2_PUBLIC_IP=${{ env.EC2_PUBLIC_IP }}" > $GITHUB_ENV
      
  #     - name: Sleep to give the instance time to initialize before deployment
  #       run: sleep 200
      
  gke-deployment:
    runs-on: ubuntu-latest
    needs: [build-and-push, test-container]

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Authenticate with GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Configure gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: automated-lodge-449109-b9

      - name: Install GKE Auth Plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin

      - name: Get GKE Cluster Credentials
        run: |
          gcloud container clusters get-credentials workflow-spacecapy --zone us-central1-c --project automated-lodge-449109-b9
          kubectl cluster-info  # Debugging step to verify the connection

      # - name: Create init.sql from Secret
      #   run: |
      #     echo "${{ secrets.INIT_SQL }}" > init.sql
      #     echo "Created init.sql from secret"

      # - name: Create or Update ConfigMap for init.sql
      #   run: |
      #     kubectl create configmap init-sql-config --from-file=init.sql --namespace=default --dry-run=client -o yaml | kubectl apply -f -
      #     echo "ConfigMap init-sql-config created/updated"

      - name: Add Helm Repository
        run: |
          helm repo add spacecapy https://AlexandraFefler.github.io/spacecapy-helm-chart
          helm repo update

      - name: Deploy to GKE with Helm
        run: |
          helm upgrade --install spacecapybara-rel spacecapy/spacecapybara-chart \
            --namespace default \
            --set image.repository=${{ secrets.DOCKER_HUB_USERNAME }}/spacecapybara_app \
            --set image.tag=1.0.${{ github.run_number }} \
            --atomic
        # --atomic flag for auto-rollback if helm deployment did't succeed. Gotta add a FAILURE CHECK here and if helm upgrade really didn't work, then catch that in the workflow and fail the whole pipeline with a proper message.

      # - name: Deploy to GKE
      #   run: |
      #     kubectl apply -f k8sDeployment.yaml
        # kubectl rollout status deployment/k8sdeployment -n YOUR_NAMESPACE

      - name: Get External IP of Space Capybara Service
        run: |
          echo "Waiting for external IP..."
          for i in {1..10}; do
            EXTERNAL_IP=$(kubectl get svc space-capybara-web --namespace default --output=jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$EXTERNAL_IP" ]; then
              echo "Space capy running at: http://$EXTERNAL_IP:5002"
              exit 0
            fi
            echo "Waiting for LoadBalancer IP to be assigned... ($i/10)"
            sleep 10
          done
          echo "‚ùå ERROR: Timed out waiting for external IP!" && exit 1