name: CI/CD pipeline

on:
  push:
    branches:
      - main

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Create .env file
        run: echo "${{ secrets.ENV_FILE }}" > .env

      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_HUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin

      - name: Build Docker image
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          docker build -t $DOCKERHUB_USER/spacecapybara_app:${VERSION} .

      - name: Push Docker image to Docker Hub (only with ver)
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          docker push $DOCKERHUB_USER/spacecapybara_app:${VERSION}
          
      - name: Push Docker image to Docker Hub (as latest stable)
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          docker tag $DOCKERHUB_USER/spacecapybara_app:${VERSION} $DOCKERHUB_USER/spacecapybara_app:latest
          docker push $DOCKERHUB_USER/spacecapybara_app:latest

  test-container:
      runs-on: ubuntu-latest
      needs: build-and-push

      steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Create required files
        run: |
          echo "${{ secrets.ENV_FILE }}" > .env
          echo "${{ secrets.INIT_SQL }}" > init.sql

      - name: Run Docker Compose
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          run: |
          echo "DOCKERHUB_USER=${DOCKERHUB_USER}" >> .env  # Inject variables into .env
          echo "VERSION=${VERSION}" >> .env  # Inject variables into .env
          cat .env  # Debugging step to verify environment variables
          docker compose up -d --force-recreate
        # run: |
        #   DOCKERHUB_USER=$DOCKERHUB_USER VERSION=$VERSION docker compose up -d --force-recreate
      
      - name: Test Application with Curl
        run: |
          sleep 30  # Wait for the container to start
          docker compose logs
          if curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:5002 | grep -q "^200$"; then
              echo "Test passed: App is responding with HTTP 200."
          else
              echo "Test failed: App is not responding with HTTP 200."
              exit 1
          fi

      - name: Stop and Clean Up Containers
        run: docker compose down

  infrastructure-provisioning:
    runs-on: ubuntu-latest
    needs: [build-and-push, test-container]

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Move to Terraform directory
        run: cd ec2_provision

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.10.4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1 

        - name: Authenticate with GCP
          run: |
            cd ec2_provision
            echo '${{ secrets.GCP_CREDENTIALS }}'
            echo '${{ secrets.GCP_CREDENTIALS }}' > gcp-key.json
            cat gcp-key.json
            export GOOGLE_APPLICATION_CREDENTIALS=$PWD/gcp-key.json
            echo "here is what in the created json: $GOOGLE_APPLICATION_CREDENTIALS"

      # - name: Authenticate with GCP
      #   run: |
      #     cd ec2_provision
      #     echo '${{ secrets.GCP_CREDENTIALS }}' | base64 --decode > gcp-key.json
      #     cat gcp-key.json
      #     export GOOGLE_APPLICATION_CREDENTIALS=$PWD/gcp-key.json
      #     echo "here is what in the created json: $GOOGLE_APPLICATION_CREDENTIALS"

      - name: Initialize Terraform
        run: |
          cd ec2_provision
          terraform init

      - name: Apply Terraform Configuration
        run: |
          cd ec2_provision
          terraform apply --auto-approve

      - name: Get EC2 Public IP
        id: get-ec2-ip
        run: |
          cd ec2_provision
          TERRAFORM_IP=$(terraform output -raw public_ip | tr -d '\n')
          echo "EC2_PUBLIC_IP is |$TERRAFORM_IP|"
          echo "EC2_PUBLIC_IP=$TERRAFORM_IP" >> $GITHUB_ENV


      - name: Store EC2 Public IP as GitHub Actions Environment Variable
        run: echo "EC2_PUBLIC_IP=${{ env.EC2_PUBLIC_IP }}" >> $GITHUB_ENV

  deployment:
    runs-on: ubuntu-latest
    needs: [build-and-push, test-container, infrastructure-provisioning]

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Connect to EC2 and deploy
        env:
          EC2_PUBLIC_IP: ${{ env.EC2_PUBLIC_IP }}
          SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_KEY }}
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
          INIT_SQL_CONTENT: ${{ secrets.INIT_SQL }}
          ENV_FILE_CONTENT: ${{ secrets.ENV_FILE }}
        run: |
          echo "Connecting to EC2 instance at $EC2_PUBLIC_IP"
          # Create SSH key
          echo "$SSH_PRIVATE_KEY" > private_key.pem
          chmod 600 private_key.pem
          scp -o StrictHostKeyChecking=no -i private_key.pem docker-compose.yml ec2-user@$EC2_PUBLIC_IP:/home/ec2-user/

          # DEBUG: Show received values in GitHub Actions before transfer
          echo "DOCKERHUB_USER=${DOCKERHUB_USER}"
          echo "VERSION=${VERSION}"

          # Upload init.sql and .env to EC2 using SCP (properly preserving multi-line content)
          echo "$INIT_SQL_CONTENT" > init.sql
          echo "$ENV_FILE_CONTENT" > .env
          
          scp -o StrictHostKeyChecking=no -i private_key.pem init.sql ec2-user@$EC2_PUBLIC_IP:/home/ec2-user/
          scp -o StrictHostKeyChecking=no -i private_key.pem .env ec2-user@$EC2_PUBLIC_IP:/home/ec2-user/

          # Connect to EC2 and execute deployment steps with variables passed directly
          ssh -o StrictHostKeyChecking=no -i private_key.pem ec2-user@$EC2_PUBLIC_IP "
            cd /home/ec2-user || exit 1

            docker-compose down -v

            # Inject variables into .env
            echo 'DOCKERHUB_USER=${DOCKERHUB_USER}' >> .env
            echo 'put dh username into .env'
            echo 'VERSION=${VERSION}' >> .env
            echo 'put dh version into .env'
            
            # DEBUG: Show contents of .env and init.sql
            echo '===== .env CONTENT ====='
            cat .env
            echo '===== init.sql CONTENT ====='
            cat init.sql

            # Run docker-compose ensuring it loads from .env
            docker-compose --env-file .env up -d --force-recreate
            echo 'did docker-compose up'
            
            sleep 20
            echo 'behold the l o g s:'
            docker-compose logs
          "
          echo "App running at http://$EC2_PUBLIC_IP:5002"

          # Clean up SSH key
          rm -f private_key.pem