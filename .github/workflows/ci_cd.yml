name: CI/CD pipeline

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'spacecapybara-chart/Chart.yaml'  # Ignores changes to this file
      - 'spacecapy-helm-chart/**'  # Ignores changes to the Helm repo

jobs:

  DEBUGGG-gcp:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Authenticate with GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Install gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: automated-lodge-449109-b9

      - name: Verify Authentication
        run: |
          gcloud auth list
          echo "-------ended the gcp auth debug thing--------"

  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Create .env file
        run: echo "${{ secrets.ENV_FILE }}" > .env

      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_HUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin

      - name: Build Docker image
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          docker build -t $DOCKERHUB_USER/spacecapybara_app:${VERSION} .

      - name: Push Docker image to Docker Hub (only with ver)
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          docker push $DOCKERHUB_USER/spacecapybara_app:${VERSION}
          
      - name: Push Docker image to Docker Hub (as latest stable)
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          docker tag $DOCKERHUB_USER/spacecapybara_app:${VERSION} $DOCKERHUB_USER/spacecapybara_app:latest
          docker push $DOCKERHUB_USER/spacecapybara_app:latest

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Cleanup old versions in Docker Hub
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          DOCKERHUB_PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
          REPOSITORY: "spacecapybara_app"
          KEEP: 5 # put that in a GHA variable instead of a hard-to-find number here
        run: |
          # Authenticate with Docker Hub
          TOKEN=$(curl -s -H "Content-Type: application/json" -X POST \
            -d '{"username": "'"$DOCKERHUB_USERNAME"'", "password": "'"$DOCKERHUB_PASSWORD"'"}' \
            https://hub.docker.com/v2/users/login/ | jq -r .token)

          echo "authenticated"

          # Fetch all tags (excluding 'latest')
          PAGE_SIZE=100
          PAGE=1
          TEMP_FILE=$(mktemp)

          while : ; do
            RESPONSE=$(curl -s -H "Authorization: JWT $TOKEN" \
              "https://hub.docker.com/v2/repositories/$DOCKERHUB_USERNAME/$REPOSITORY/tags/?page_size=$PAGE_SIZE&page=$PAGE")

            echo "$RESPONSE" | jq -r '.results[] | select(.name != "latest") | "\(.name) \(.last_updated)"' >> "$TEMP_FILE"

            [ "$(echo "$RESPONSE" | jq -r '.next')" == "null" ] && break
            PAGE=$((PAGE + 1))
          done

          # Sort tags by last updated time (latest first)
          SORTED_TAGS=($(sort -k2 -r "$TEMP_FILE" | awk '{print $1}'))

          # Determine tags to delete (everything except the latest $KEEP versions)
          DELETE_TAGS=("${SORTED_TAGS[@]:$KEEP}")

          # Delete old tags
          for TAG in "${DELETE_TAGS[@]}"; do
            echo "Deleting tag: $TAG"
            curl -s -X DELETE -H "Authorization: JWT $TOKEN" \
              "https://hub.docker.com/v2/repositories/$DOCKERHUB_USERNAME/$REPOSITORY/tags/$TAG/"
          done

  test-container:
      runs-on: ubuntu-latest
      needs: build-and-push

      steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Create required files
        run: |
          echo "${{ secrets.ENV_FILE }}" > .env
          echo "${{ secrets.INIT_SQL }}" > init.sql

      - name: Run Docker Compose
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKER_HUB_USERNAME }}
          VERSION: 1.0.${{ github.run_number }}
        run: |
          run: |
          echo "DOCKERHUB_USER=${DOCKERHUB_USER}" >> .env  # Inject variables into .env
          echo "VERSION=${VERSION}" >> .env  # Inject variables into .env
          cat .env  # Debugging step to verify environment variables
          docker compose up -d --force-recreate
        # run: |
        #   DOCKERHUB_USER=$DOCKERHUB_USER VERSION=$VERSION docker compose up -d --force-recreate
      
      - name: Test Application with Curl
        run: |
          sleep 30  # Wait for the container to start
          docker compose logs
          if curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:5002 | grep -q "^200$"; then
              echo "Test passed: App is responding with HTTP 200."
          else
              echo "Test failed: App is not responding with HTTP 200."
              exit 1
          fi

      - name: Stop and Clean Up Containers
        run: docker compose down

# TODO: push latest after test!! 


  build-and-publish-helm:
    runs-on: ubuntu-latest
    needs: [build-and-push, test-container]

    permissions:
      contents: write  # ✅ Ensure write access for GitHub Actions

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Create init.sql from Secret
        run: | 
          cd spacecapybara-chart
          pwd
          mkdir -p files  # Ensure directory exists
          echo "${{ secrets.INIT_SQL }}" > files/init.sql
          echo "Created files/init.sql from secret"

      - name: Update Chart Version
        run: |
          CHART_FILE="spacecapybara-chart/Chart.yaml"
          CURRENT_VERSION=$(grep '^version:' $CHART_FILE | awk '{print $2}')

          echo "_________The current version variable content:__________"
          grep '^version:' $CHART_FILE | awk '{print $2}'

          MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
          MINOR=$(echo $CURRENT_VERSION | cut -d. -f2)
          PATCH=$(echo $CURRENT_VERSION | cut -d. -f3)
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          sed -i "s/^version:.*/version: $NEW_VERSION/" $CHART_FILE
          echo "Updated Helm chart version to $NEW_VERSION"


      - name: Configure Git Credentials
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/AlexandraFefler/devops1114_spacecapybara.git



      - name: Commit Updated Chart.yaml
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Pull the latest changes to avoid conflicts
          git pull --rebase origin main || echo "No remote changes to rebase"

          git add spacecapybara-chart/Chart.yaml
          git commit -m "CI: Bump Helm chart version [skip ci]" || echo "No changes to commit"

          # Force push only if rebase was needed
          git push origin main || (git pull --rebase origin main && git push origin main)
        # git push origin main
 
      - name: Package Helm Chart
        run: |
          cd spacecapybara-chart
          helm package .
          mv spacecapybara-chart-*.tgz ../

      - name: Clone Helm Repository
        run: |
          pwd
          git clone https://github.com/AlexandraFefler/spacecapy-helm-chart.git
          cd spacecapy-helm-chart
          git config user.name "AlexandraFefler"
          git config user.email "AlexandraFefler@users.noreply.github.com"
          git remote set-url origin https://x-access-token:${{ secrets.SPACECAPY_HELM_PAT }}@github.com/AlexandraFefler/spacecapy-helm-chart.git

      
          - name: Move Helm Package to Repo and Clean Up Old Versions
          run: |
            ls
            mv spacecapybara-chart-*.tgz spacecapy-helm-chart/
            echo "__________________DEBUG___________________"
            pwd
            ls
            echo "__________________DEBUG___________________"
            cd spacecapy-helm-chart
            
            # Cleanup old Helm charts before committing
            echo "_______Cleaning up to keep 5 newest chart versions_______"
            
            # Get list of chart files sorted oldest first
            CHART_FILES=($(ls -tr spacecapybara-chart-*.tgz 2>/dev/null || echo ""))
            TOTAL_CHARTS=${#CHART_FILES[@]}
  
            if [ "$TOTAL_CHARTS" -gt 5 ]; then
              DELETE_COUNT=$((TOTAL_CHARTS - 5))
              echo "Found $TOTAL_CHARTS chart versions, deleting $DELETE_COUNT oldest versions..."
  
              # Keep the last 5 (newest) and delete the rest
              for ((i=0; i<DELETE_COUNT; i++)); do
                echo "Deleting: ${CHART_FILES[$i]}"
                rm -f "${CHART_FILES[$i]}"
              done
            else
              echo "No cleanup needed, less than or equal to 5 versions present."
            fi
  
            # Ensure index.yaml and README.md are NOT deleted
            echo "Ensuring important files remain..."
            git checkout -- README.md index.yaml || true
  
            # Rebuild Helm repo index
            helm repo index . --url https://AlexandraFefler.github.io/spacecapy-helm-chart
  
            # Fix the embedded Git issue (remove submodule reference)
            cd ..
            git rm -r --cached spacecapy-helm-chart || true
            git add spacecapy-helm-chart
            git commit -m "Updated Helm chart to new version and cleaned old versions"
            git push origin main
  



  gke-infrastructure-provisioning:
    runs-on: ubuntu-latest
    needs: [build-and-push, test-container, build-and-publish-helm]

    outputs:
      GKE_CLUSTER_NAME: ${{ env.GKE_CLUSTER_NAME }}
      GKE_ZONE: ${{ env.GKE_ZONE }}
      GCP_PROJECT_ID: ${{ env.GCP_PROJECT_ID }}

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
      
      ###_________________Google auth start________________###

      - name: Authenticate with GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Configure gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: automated-lodge-449109-b9

      - name: Install GKE Auth Plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin

      ###_________________Google auth end__________________###

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1 

      - name: Move to Terraform directory
        run: cd tf-to-gke

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.10.4

      - name: Initialize Terraform
        run: |
          cd tf-to-gke
          terraform init

      - name: Apply Terraform Configuration
        run: |
          cd tf-to-gke
          terraform apply --auto-approve
          echo "_____________________done_______________________"

      - name: Extract GKE Cluster Information
        id: get-gke-info
        run: |
          cd tf-to-gke
  
          # Extract clean Terraform outputs
          CLUSTER_NAME=$(terraform output -raw kubernetes_cluster_name | awk -F'::debug::stdout: ' '{print $2}' | awk -F' ::debug::stderr:' '{print $1}' | tr -d '\r' | xargs)
          ZONE=$(terraform output -raw zone | awk -F'::debug::stdout: ' '{print $2}' | awk -F' ::debug::stderr:' '{print $1}' | tr -d '\r' | xargs)
          PROJECT_ID=$(terraform output -raw project_id | awk -F'::debug::stdout: ' '{print $2}' | awk -F' ::debug::stderr:' '{print $1}' | tr -d '\r' | xargs)

          echo "__________The passed details from output:__________"
          echo "GKE_CLUSTER_NAME: $CLUSTER_NAME"
          echo "__________________b o n k___________________"
          echo "GKE_ZONE: $ZONE"
          echo "__________________b o n k___________________"
          echo "GCP_PROJECT_ID: $PROJECT_ID"
          echo "__________________b o n k___________________"
  
          # Store in Environment Variables (new method)
          echo "GKE_CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          echo "GKE_ZONE=$ZONE" >> $GITHUB_ENV
          echo "GCP_PROJECT_ID=$PROJECT_ID" >> $GITHUB_ENV
      
      - name: Sleep to give the cluster time before deployment
        run: sleep 20

      # - name: Get EC2 Public IP
      #   id: get-ec2-ip
      #   run: |
      #     cd tf-to-gke
      #     TERRAFORM_IP=$(terraform output -raw public_ip | awk 'match($0, /([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/) {print substr($0, RSTART, RLENGTH); exit}')
      #     echo "Extracted EC2_PUBLIC_IP: '$TERRAFORM_IP'"
      #     echo "EC2_PUBLIC_IP=$TERRAFORM_IP" >> $GITHUB_ENV
      #     echo "::set-output name=EC2_PUBLIC_IP::$TERRAFORM_IP"


      # - name: Store EC2 Public IP as GitHub Actions Environment Variable
      #   run: echo "EC2_PUBLIC_IP=${{ env.EC2_PUBLIC_IP }}" > $GITHUB_ENV
      
      # - name: Sleep to give the instance time to initialize before deployment
      #   run: sleep 200

  gke-deployment:
    runs-on: ubuntu-latest
    needs: [build-and-push, test-container, build-and-publish-helm, gke-infrastructure-provisioning]

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      ###_________________Google auth start________________###

      - name: Authenticate with GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Configure gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: automated-lodge-449109-b9

      - name: Install GKE Auth Plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin

      ###_________________Google auth end__________________###

      - name: Get GKE Cluster Credentials
        env:
          GKE_CLUSTER_NAME: ${{ needs.gke-infrastructure-provisioning.outputs.GKE_CLUSTER_NAME }}
          GKE_ZONE: ${{ needs.gke-infrastructure-provisioning.outputs.GKE_ZONE }}
          GCP_PROJECT_ID: ${{ needs.gke-infrastructure-provisioning.outputs.GCP_PROJECT_ID }}
        run: |
          echo "Fetching GKE cluster credentials..."
          gcloud container clusters get-credentials $GKE_CLUSTER_NAME --zone $GKE_ZONE --project $GCP_PROJECT_ID
          kubectl cluster-info  # Debugging step to verify the connection

      # - name: Get GKE Cluster Credentials
      #   run: |
      #     gcloud container clusters get-credentials automated-lodge-449109-b9-gke --region us-central1 --project automated-lodge-449109-b9
      #     kubectl cluster-info  # Debugging step to verify the connection

      # - name: Create init.sql from Secret
      #   run: |
      #     echo "${{ secrets.INIT_SQL }}" > init.sql
      #     echo "Created init.sql from secret"

      # - name: Create or Update ConfigMap for init.sql
      #   run: |
      #     kubectl create configmap init-sql-config --from-file=init.sql --namespace=default --dry-run=client -o yaml | kubectl apply -f -
      #     echo "ConfigMap init-sql-config created/updated"

      - name: Add Helm Repository
        run: |
          helm repo add spacecapy https://AlexandraFefler.github.io/spacecapy-helm-chart
          helm repo update

      - name: Deploy to GKE with Helm
        run: |
          helm upgrade --install spacecapybara-rel spacecapy/spacecapybara-chart \
            --namespace default \
            --set image.repository=${{ secrets.DOCKER_HUB_USERNAME }}/spacecapybara_app \
            --set image.tag=1.0.${{ github.run_number }} \
            --atomic
        # --atomic flag for auto-rollback if helm deployment did't succeed. Gotta add a FAILURE CHECK here and if helm upgrade really didn't work, then catch that in the workflow and fail the whole pipeline with a proper message.

      # - name: Deploy to GKE
      #   run: |
      #     kubectl apply -f k8sDeployment.yaml
        # kubectl rollout status deployment/k8sdeployment -n YOUR_NAMESPACE

      - name: Install Prometheus
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          helm upgrade --install prometheus prometheus-community/prometheus \
            --namespace monitoring --create-namespace \
            --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false # chat, is this needed now? what is this anyway? 

      - name: Install Grafana
        run: |
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update
          helm upgrade --install grafana grafana/grafana \
            --namespace monitoring \
            --set adminPassword=admin \
            --set grafana.security.disableInitialAdminPasswordChange=true
        # might want to put admin password in a GHA secret later

      - name: Apply Custom Prometheus Config
        run: |
          kubectl apply -f prometheus-config.yaml
        # add check if this is already applied ig (maybe by the config map it creates if it ddid run b4)

      - name: Restart Prometheus Server Pod
        run: |
          PROMETHEUS_POD=$(kubectl get pods -n monitoring -l app.kubernetes.io/name=prometheus -o jsonpath="{.items[0].metadata.name}")
          kubectl delete pod $PROMETHEUS_POD -n monitoring


      - name: Get External IP of Space Capybara Service
        run: |
          echo "Waiting for external IP..."
          for i in {1..10}; do
            EXTERNAL_IP=$(kubectl get svc space-capybara-web --namespace default --output=jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$EXTERNAL_IP" ]; then
              echo "Space capy running at: http://$EXTERNAL_IP:5002"
              exit 0
            fi
            echo "Waiting for LoadBalancer IP to be assigned... ($i/10)"
            sleep 10
          done
          echo "❌ ERROR: Timed out waiting for external IP!" && exit 1